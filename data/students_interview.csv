Tabella 1;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;
student-28;Accept;C#, JS, TS, C/C++, python;4;2;MongoDB;3;OpenCypher;match (n) return distinct labels(n);match ()-[r]-() return distinct type(r) ;"MATCH (n) RETURN DISTINCT labels(n), keys(n) 
";MATCH ()-[r]->() RETURN DISTINCT type(r) AS RelationshipType, keys(r) AS RelationshipProperties;"MATCH (n)-[r]->() RETURN DISTINCT labels(n) AS Source, type(r) AS Relationship, labels(endNode(r)) AS Target, count(*) AS Count;


MATCH (n)-[r]->(m)
RETURN n, type(r), m 
LIMIT 100;


MATCH (n)
RETURN labels(n) AS Node_Type, count(*) AS Count
ORDER BY Count DESC;";https://drive.google.com/open?id=1cS_rRR6AIcWSwMx5JHHg4VI9Dr6AFOkQ;"match (p:Pangenome)<-[:IS_IN_PANGENOME]-(:Family)<-[:IS_IN_FAMILY]-(g:Gene) 
return p.name,size(collect(g))";"match (p:Pangenome)<-[:IS_IN_PANGENOME]-(:Family)<-[:IS_IN_FAMILY]-(:Gene)-[:IS_IN_RGP]->(:RGP)-[:IS_IN_SPOT]->(s:Spot) 
return p.name,size(collect(s))";match (p:Pangenome)<-[:IS_IN_PANGENOME]-(f:Family)-[:IS_IN_MODULE]->(m:Module) match  (p:Pangenome)<-[:IS_IN_PANGENOME]-(f:Family)-[sim:IS_SIMILAR]->(f2:Family) where sim.identity >= 0.8 return p.name as Pangenome, size(collect(m)) as modules;match (p1:Pangenome)-[:IS_IN_PANGENOME]-(f1:Family)-[s:IS_SIMILAR]-(f2:Family)-[:IS_IN_PANGENOME]-(p2:Pangenome) where f1.annotation is not null and f2.annotation is not null and s.identity >= 0.8 return p1.name as pangenome1, f1.name as family1, p2.name as pangenome2, f2.name as family2, s.identity as similarity;match (p:Pangenome)-[:IS_IN_PANGENOME]-(f:Family)-[:NEIGHBOR]-(f2:Family) where f2.annotation is not null return p.name, f2.name;match (p:Pangenome)-[:IS_IN_PANGENOME]-(f:Family) where f.annotation is not null return p.name, count(DISTINCT f);"match (m:Module)-[:IS_IN_MODULE]-(f:Family)-[sim:IS_SIMILAR]-(f2:Family)
return m.name, avg(sim.identity) as averageSim order by averageSim desc";"MATCH (m:Module)-[:IS_IN_MODULE]-(f1:Family)-[sim:IS_SIMILAR]-(f2:Family)
WITH m, MIN(sim.identity) AS min_similarity, MAX(sim.identity) AS max_similarity
ORDER BY min_similarity ASC LIMIT 1 MATCH (m1:Module)-[:IS_IN_MODULE]-(f3:Family)-[sim1:IS_SIMILAR]-(f4:Family)
WITH m, min_similarity, max_similarity, m1, MAX(sim1.identity) AS max_similarity1
ORDER BY max_similarity1 DESC LIMIT 1 RETURN m.name AS module_min_similarity, min_similarity,m1.name AS module_max_similarity, max_similarity1";match (f:Family)-[:IS_IN_MODULE]-(m:Module) return f.name, count(m) as modules order by modules desc limit 10;MATCH (f1:Family)-[s:IS_SIMILAR]->(f2:Family) WHERE s.identity >= 0.8 AND s.coverage >= 0.8 WITH f1, f2, s ORDER BY s.identity DESC, s.coverage DESC LIMIT 10 MATCH (f1)-[:HAS_PARTITION]->(p1:Partition) MATCH (f2)-[:HAS_PARTITION]->(p2:Partition) RETURN f1.name AS Family1, f2.name AS Family2, p1.subpartition AS Partition1, p2.subpartition AS Partition2
;;;;;;;;Correct;Correct;Correct;Correct;2;https://drive.google.com/open?id=1cS_rRR6AIcWSwMx5JHHg4VI9Dr6AFOkQ;Semantic Return | Missing Distinct;Semantic Return | Wrong information (count instead of list);Semantic Where | Missing Condition, Wrong Property;Complication | Additional Information;Semantic Where , Semantic Return | Missing Condition, Missing Information;Correct;Semantic Pattern | Wrong Edge Direction;Semantic Pattern, Semantic Return | Additional Node, Missing Information;Correct;Complication | Added With
;;;;;;;;;;;;I forgot.;;"Why you didn’t put the distinct inside the collect? I forgot. Why Size instead of count? Because size is used with collect and count is used to return the number of answers; I used collect previously so I also used size.";Why Size/Count? Misunderstanding of the question? Same as before.;Why identity >= 0.8 instead of coverage? You didn’t understand the difference? Because of the property name. Why you didn’t put put <> between the two families? I did not think this is possible in practice. Question about the “join” : 2 nodes with same labels are different? Yes, same label does not mean the nodes are the same.;;Why you didn’t put also f1.annotation is not null? And why you didn’t return both families? Comprehension error of the question? I forgot.;;;;;
Student-29;Accept;Javascript, Java, PHP, C, OCaml, C#, Dart;5;2;MongoDB;1;;"CALL db.labels() YIELD label
RETURN DISTINCT label;";"CALL db.relationshipTypes() YIELD relationshipType RETURN DISTINCT relationshipType;";"MATCH (n)
WITH labels(n) AS nodeLabels, keys(n) AS nodeProperties
UNWIND nodeLabels AS nodeLabel
RETURN DISTINCT nodeLabel, COLLECT(DISTINCT nodeProperties) AS properties;";"MATCH ()-[r]->() WITH type(r) AS relationshipType, keys(r) AS relationshipProperties RETURN DISTINCT relationshipType, COLLECT(DISTINCT relationshipProperties) AS properties;";"MATCH (n)
RETURN DISTINCT labels(n) AS nodeLabels, COUNT(*) AS count


MATCH ()-[r]->()
RETURN DISTINCT type(r) AS relationshipType, COUNT(*) AS count


MATCH (n:Type)
UNWIND keys(n) AS property
RETURN DISTINCT property


MATCH (n:Type)
UNWIND keys(n) AS property
RETURN DISTINCT property


MATCH (n)
RETURN labels(n) AS nodeLabels, properties(n) AS nodeProperties


MATCH (n:Type)-[r]-(m)
WHERE type(r) <> 'REL_TYPE'
RETURN r, m;";https://drive.google.com/open?id=1-l6qrXoMVKyPMNYrio_qXIOSGHzr1hsi;"// the following request gets the list of pangenomes and for each pangenome the list of distinct associated gene ids

MATCH (p:Pangenome)-[:IS_IN_PANGENOME]-(:Family)-[:IS_IN_FAMILY]-(g:Gene)
RETURN p.name as p_name, COLLECT(DISTINCT id(g)) AS p_g_ids

// assuming all gene names are different, we could also use the following approach, which is probably more readable as it prints out the genes's names instead of their ids.

MATCH (p:Pangenome)-[:IS_IN_PANGENOME]-(:Family)-[:IS_IN_FAMILY]-(g:Gene)
RETURN p.name as p_name, COLLECT(DISTINCT g.names) AS p_g_names

// However, it would seem that one of the pangenomes is attached to a lot of genes that have no name. We'll stick to the first approach then";"// We follow the exact same approach as the previous question, this time with a slightly different path

MATCH (p:Pangenome)-[:IS_IN_PANGENOME]-(:Family)-[:IS_IN_FAMILY]-(:Gene)-[:IS_IN_RGP]-(:RGP)-[:IS_IN_SPOT]-(s:Spot)
RETURN p.name as p_name, COLLECT(DISTINCT id(s)) AS p_s_ids";MATCH (p:Pangenome)-[:IS_IN_PANGENOME]-(f:Family)-[:IS_IN_MODULE]-(m:Module) MATCH (f)-[r:IS_SIMILAR]-(f2:Family) WHERE r.identity > 0.8 RETURN p.name as p_name, COLLECT(DISTINCT id(m)) AS p_m_ids, r;MATCH (p1:Pangenome)-[:IS_IN_PANGENOME]-(f1:Family)-[r:IS_SIMILAR]-(f2:Family)-[:IS_IN_PANGENOME]-(p2:Pangenome) WHERE p1 <> p2  AND r.identity > 0.8  AND f1.annotation IS NOT NULL  AND f2.annotation IS NOT NULL RETURN f1.name, f2.name;MATCH (p1:Pangenome)-[:IS_IN_PANGENOME]-(f1:Family)-[:NEIGHBOR]-(f2:Family) WHERE f1.annotation IS NOT NULL  AND f2.annotation IS NOT NULL  AND f1 <> f2 RETURN p1.name AS pan, COLLECT({f1_id: id(f1), f2_id: id(f2)}) AS neighborhood_pairs__list;MATCH (p1:Pangenome)-[:IS_IN_PANGENOME]-(f1:Family) WHERE f1.annotation IS NOT NULL RETURN p1.name AS p_name, size(COLLECT(f1)) AS annotation_family_amount;"MATCH (m:Module)-[:IS_IN_MODULE]-(:Family)-[r:IS_SIMILAR]-(:Family)-[:IS_IN_MODULE]-(m)
WITH m, AVG(r.identity) AS avg_similarity
RETURN m.name AS module_name, avg_similarity
ORDER BY avg_similarity DESC;";Because I wanted a single response and I thought it was easier using MAX and MIN rather than ORDER BY/LIMIT.;"MATCH (f:Family)-[:IS_IN_MODULE]-(:Module) WITH f, COUNT(DISTINCT f) AS module_count RETURN f.name AS gene_family, module_count ORDER BY module_count DESC LIMIT 10;";MATCH (f1:Family)-[:HAS_PARTITION]-(p:Partition) MATCH (f1)-[r:IS_SIMILAR]-(f2:Family) WHERE r.identity > 0.8 AND r.coverage > 0.8 RETURN f1, f2, p.partition ORDER BY r.identity, r.coverage LIMIT 10
;;;;;;;;Other;Other;Complication | Added Collect, Added With, Added Unwind;Complication | Added With, Added Collect;1;https://drive.google.com/open?id=1-l6qrXoMVKyPMNYrio_qXIOSGHzr1hsi;Complication | Added Collect in return shape;Semantic Return | Missing Distinct;Semantic Where | Missing Condition, Wrong Property;Semantic Where | Wrong Operator (> instead of >=);Semantic Return | Wrong Information;Complication | Added Size(collect);Semantic Pattern | Wrong Edge Direction, Additional Node;Semantic Return | Missing Limit, Missing Information;Correct;Semantic Where, Semantic Return | Wrong Operator, Missing Information
;;;;;;;;;; With With? To access the labels. Why Collect and Unwind? To eliminate duplicates and for better formatting.;Why Collect and with? Same reason as for the nodes.;;;;;Why identity >= 0.8 instead of coverage? You didn’t understand the difference? Incomprehension. Why you didn’t put put <> between the two families? Assumption that in practice one cannot have cyclic relation with IS_SIMILAR, despite looking at the schema. Assumption that in practice the same instance cannot be related via edges with this label. Question about the “join” : 2 nodes with same labels are different? ? No, they can be the same. ;Why > instead of >=? Language misunderstanding? Because there were no answers if we only use >. ;;;;Why you didn’t put the limit? Because I wanted a single response and I thought it was easier using MAX and MIN rather than ORDER BY/LIMIT. And didn’t return the couples of similar modules? MissComprehension of the question? It was hard to write the query and to handle the return values because there were 2 subqueries in one.;;Why > instead of >= ? Because no answer with >.
student-27;Accept;C,C#,C++,Java, Python, PHP, R, JS, Angular, TypeScript...;4;4;Apache Cassandra, MongoDB, Couchbase;2;SQL/PGQ;"MATCH (n) RETURN DISTINCT labels(n);";MATCH ()-[r]-() RETURN DISTINCT type(r) ;"MATCH (n) RETURN DISTINCT labels(n) AS Label,  keys(n) AS Properties;";"MATCH ()-[r]->() RETURN DISTINCT type(r) AS RelationshipType, keys(r) AS Properties;";"Match (n) return lables(n) as typen , count(*) as totaltypes order by desc


MATCH (n)-[r]->() RETURN DISTINCT labels(n) AS SourceLabel, type(r) AS RelationshipType, labels(endNode(r)) AS TargetLabel, count(*) AS Count


MATCH (n) RETURN DISTINCT labels(n) AS NodeLabel, size(keys(n)) AS NumProperties, keys(n) AS Properties
";https://drive.google.com/open?id=1D_haPeUdUXpb3xFUohkfn3TxR-rpYVoB;MATCH (p:Pangenome)-[:IS_IN_PANGENOME]-(f:Family)-[:IS_IN_FAMILY]-(g:Gene) RETURN p.name, size(collect(g));MATCH (p:Pangenome)-[:IS_IN_PANGENOME]-(f:Family)-[:IS_IN_FAMILY]-(g:Gene)-[:IS_IN_RGP]-(r:RGP)-[:IS_IN_SPOT]-(s:Spot) RETURN p.name, size(collect(s));match (p:Pangenome)<-[:IS_IN_PANGENOME]-(f:Family)-[:IS_IN_MODULE]->(m:Module) match  (p:Pangenome)<-[:IS_IN_PANGENOME]-(f:Family)-[s:IS_SIMILAR]->(f2:Family) where s.identity > 0.8 return p , collect(m);match (p1:Pangenome)-[:IS_IN_PANGENOME]-(f1:Family)-[s:IS_SIMILAR]-(f2:Family)-[:IS_IN_PANGENOME]-(p2:Pangenome) where f1.annotation is not null and f2.annotation is not null and s.identity > 0.8 return p1.name as pangenome1, f1.name as family1, p2.name as pangenome2, f2.name as family2, s.identity as similarity;match (p:Pangenome)-[:IS_IN_PANGENOME]-(f:Family)-[:NEIGHBOR]-(f2:Family) where f2.annotation is not null return p.name, f2.name;MATCH (p:Pangenome)-[:IS_IN_PANGENOME]-(f:Family) where f.annotation is not null RETURN p.name AS Pangenome_Name, COUNT(DISTINCT f) AS Number_of_Annotated_Families;MATCH (m:Module)-[:IS_IN_MODULE]-(f:Family)-[s:IS_SIMILAR]-(f2:Family)  RETURN m.name AS Module_Name, AVG(s.identity) AS avg_similarity ORDER BY avg_similarity DESC;"MATCH (m:Module)-[:IS_IN_MODULE]-(f1:Family)-[sim:IS_SIMILAR]-(f2:Family)
WITH m, MIN(sim.identity) AS min_similarity, MAX(sim.identity) AS max_similarity
ORDER BY min_similarity ASC LIMIT 1 MATCH (m1:Module)-[:IS_IN_MODULE]-(f3:Family)-[sim1:IS_SIMILAR]-(f4:Family)
WITH m, min_similarity, max_similarity, m1, MAX(sim1.identity) AS max_similarity1
ORDER BY max_similarity1 DESC LIMIT 1 RETURN m.name AS module_min_similarity, min_similarity,m1.name AS module_max_similarity, max_similarity1";MATCH (f:Family)-[:IS_IN_MODULE]->(m:Module) RETURN f.name AS Gene_Family, COUNT(DISTINCT m) AS num_modules ORDER BY num_modules DESC LIMIT 10;MATCH (f1:Family)-[s:IS_SIMILAR]->(f2:Family) WHERE s.identity >= 0.8 AND s.coverage >= 0.8 WITH f1, f2, s ORDER BY s.identity DESC, s.coverage DESC LIMIT 10 MATCH (f1)-[:HAS_PARTITION]->(p1:Partition) MATCH (f2)-[:HAS_PARTITION]->(p2:Partition) RETURN f1.name AS Family1, f2.name AS Family2, p1.subpartition AS Partition1, p2.subpartition AS Partition2
;;;;;;;;Correct;Correct;Correct;Correct;0;https://drive.google.com/open?id=1D_haPeUdUXpb3xFUohkfn3TxR-rpYVoB;Semantic Return | Missing Distinct;Semantic Return | Wrong information (count instead of list);Semantic Where | Missing Condition, Wrong Property;Semantic Where | Wrong Operator (> instead of >=);Semantic Where , Semantic Return | Missing Condition, Missing Information;Correct;Semantic Pattern | Wrong Edge Direction;Semantic Pattern, Semantic Return | Additional Node, Missing Information;Correct;Complication | Added With 
;;;;;;;;;;;;;;;;Why identity >= 0.8 instead of coverage? You didn’t understand the difference?  Because of the property name. Why you didn’t put put <> between the two families? Forgot. Though that different variable names indicate different objects. Question about the “join” : 2 nodes with same labels are different? Yes.;Why > instead of >=? Language misunderstanding? When we do > we do not get any results, so chanced to >=.;Why you didn’t put also f1.annotation is not null? Assumed for f1 annotations are always missing. And why you didn’t return both families? Comprehension error of the question? Comprehension error.;;;;;
student-36;Accept;C,C++,C#,Java,Shell,Bash,Python,Ocaml,RSC-V,html,css;3;3;Other;3;OpenCypher, SQL/PGQ;"
match (a) return distinct labels(a)";match ()-[r]-() return distinct type(r);match (a) unwind keys(a) as prop return labels(a) as node_label, COLLECT(DISTINCT prop) as properties;match ()-[r]-()  unwind keys(r) as prop return type(r) as node_type, COLLECT(DISTINCT prop) as properties;"Afin de savoir quels noeuds sont reliés entre eux et par quelles relations, dans quel sens, avec quelles étiquettes : 
match (a)-[r]->(b) return distinct labels(a) as prop_source, labels(b) as prop_target, type(r) as relation_type, keys(r) as key_relation

On vérifie qu'on a rien oublié grâce aux questions précédentes
";https://drive.google.com/open?id=15AA9UKD6Q1BCcRGOGxXyf2np0ZQzVakG;"MATCH (a:Pangenome)<-[:IS_IN_PANGENOME]-(b:Family)<-[:IS_IN_FAMILY]-(c:Gene)
WITH a.name as pange_name, c.name AS gene_name, id(c) AS gene_id
RETURN DISTINCT pange_name, COLLECT(distinct[gene_name, gene_id]) AS gene_info
ORDER BY pange_name ";"MATCH (a:Pangenome)<-[:IS_IN_PANGENOME]-(b:Family)<-[:IS_IN_FAMILY]-(c:Gene)-[:IS_IN_RGP]->(d:RGP)-[:IS_IN_SPOT]->(e:Spot)
WITH a.name as pange_name, e.name AS spot_name, id(e) AS spot_id
RETURN DISTINCT pange_name, COLLECT(distinct[spot_name, spot_id]) AS spot_info
ORDER BY pange_name";MATCH (a:Pangenome)<-[:IS_IN_PANGENOME]-(b1:Family)-[r:IS_SIMILAR]-(b2:Family)-[:IS_IN_MODULE]->(c:Module) WITH a.name AS pange_name, c.name AS module_name, b1.name AS fam1_name, b2.name AS fam2_name, COLLECT(r.identity) AS identities WHERE any(id IN identities WHERE id >= 0.8) RETURN DISTINCT pange_name, COLLECT(DISTINCT module_name), COLLECT(DISTINCT [fam1_name, identities, fam2_name]) AS family_info;MATCH (a:Pangenome)<-[:IS_IN_PANGENOME]-(b1:Family)-[r:IS_SIMILAR]-(b2:Family)-[:IS_IN_PANGENOME]->(c:Pangenome) WHERE EXISTS(b1.annotation) AND EXISTS(b2.annotation) and id(a)<>id(c) WITH a.name AS pange_name, b1.name AS fam1_name, b2.name AS fam2_name, b1.annotation as annot, COLLECT(r.identity) AS identities WHERE ALL(id IN identities WHERE id >= 0.8) RETURN DISTINCT [fam1_name,identities, fam2_name,annot] AS family_info;MATCH (p:Pangenome)<-[:IS_IN_PANGENOME]-(f:Family)<-[:NEIGHBOR]-(neighbor:Family) WHERE EXISTS(f.annotation) and exists(neighbor.annotation) RETURN p.name AS pangenome, f.name AS family_name, COLLECT(DISTINCT neighbor.name) AS neighborhood;MATCH (p:Pangenome)<-[:IS_IN_PANGENOME]-(f:Family) WHERE EXISTS(f.annotation) with p.name as pangenome, COLLECT(distinct f) AS neighborhood RETURN pangenome, size(neighborhood) as nb_families_annotated;"MATCH (m:Module)<-[:IS_IN_MODULE]-(f:Family)-[r:IS_SIMILAR]-(other:Family)
WITH m.name AS module, f, AVG(r.identity) AS avg_similarity
RETURN distinct module, AVG(avg_similarity) AS average_similarity
ORDER BY average_similarity DESC";"MATCH (m:Module)<-[:IS_IN_MODULE]-(f1:Family)-[r:IS_SIMILAR]-(f2:Family)-[:IS_IN_MODULE]->(m)
WITH m.name AS module, MIN(r.identity) AS min_similarity, MAX(r.identity) AS max_similarity
MATCH (m_min:Module)<-[:IS_IN_MODULE]-(f1:Family)-[min_rel:IS_SIMILAR {identity: min_similarity}]->(f2:Family)
MATCH (m_max:Module)<-[:IS_IN_MODULE]-(f3:Family)-[max_rel:IS_SIMILAR {identity: max_similarity}]->(f4:Family)
RETURN [m_min.name, [f1.name,f2.name]],[m_max.name,[f3.name,f4.name]]";MATCH (f:Family)-[:IS_IN_MODULE]->(m:Module) WITH f.name as gene_family , collect(DISTINCT id(m)) AS modules RETURN gene_family, size(modules) as nb_module ORDER BY nb_module DESC LIMIT 10;I didn't do the Q13, so I don't know how to do this question
;;;;;;;;Correct;Correct;Complication | Added Collect;Complication | Added Unwind, Added Collect;1;https://drive.google.com/open?id=15AA9UKD6Q1BCcRGOGxXyf2np0ZQzVakG;Semantic Return | Wrong Distinct (on couple name,id);Semantic Return | Wrong Distinct (on couple name,id);Semantic Where, Semantic Return | Missing Condition,Wrong Property, Wrong Information;Semantic Return | Wrong Information;Complication | Added Collect;Complication | Added Size(collect);Semantic Pattern | Wrong Edge Direction;Semantic Return |Missing Limit;Correct;No Answer
;;;;;;;;;;Why Collect? When one has to aggregate values, I assume I need to use a list for readability purposes.;Why Collect and unwind? I wanted to collect the result in a list and not have multiple tuples, because having multiple rows is harder to read. We have only 2 lines returned so it is simpler for the user.;;;Why distinct and collect on the couple? When we need to use multiple distincts, I use collect you regroup the information. If I only use collect without distinct I do not get the results I wanted.;Why distinct and collect on the couple? Same as before.;Why identity >= 0.8 instead of coverage? You didn’t understand the difference? I misunderstood. Why you didn’t put put <> between the two families? I did not understand I needed to do it for this question. Question about the “join” : 2 nodes with same labels are different? Yes, they can different, but this needs to be tested.;;;;;;;
student-38;Accept;JavaScript , Java , C , C++ , Python , HTML;4;3;MongoDB;3;OpenCypher;MATCH (n) RETURN DISTINCT labels(n);MATCH ()-[r]-() RETURN DISTINCT type(r);MATCH (n) RETURN DISTINCT labels(n), keys(n);MATCH ()-[r]-() RETURN DISTINCT type(r),keys(r);"On va récupérer les associations ainsi les étiquettes qu'elles relient

MATCH (a)-[r]->(b) return distinct type(r),labels(a),labels(b)

On va se focaliser sur le label ""Gene"" et voir toutes ses propriétés

MATCH (n) WHERE labels(n) = [""Gene""] RETURN DISTINCT labels(n),keys(n)

On va voir les associations sans propriétés
MATCH ()-[r]-() WHERE keys(r)=[] RETURN DISTINCT type(r)

Les associations avec au moins une propriété
MATCH ()-[r]-() WHERE NOT keys(r)=[] RETURN DISTINCT type(r)
";Comprehension error. I did not see that both families had to have annotations.;"MATCH (p:Pangenome)-[*2]-(g:Gene)
RETURN p.name, COLLECT(distinct(g.name)) AS AssociatedGenes";"MATCH (p:Pangenome)-[]-(:Family)-[]-(:Gene)-[]-(:RGP)-[]-(s:Spot)
RETURN p.name, COLLECT(distinct(s.name)) AS AssociatedSpots";match (p:Pangenome)-[*2]-(m:Module)-[]-(f1:Family)-[sim:IS_SIMILAR]-(f2:Family) WHERE (f2)-[:IS_IN_MODULE]-(m) AND sim.identity>=0.8 RETURN p,m,f1,f2;match (p1:Pangenome)-[]-(f1:Family)-[sim:IS_SIMILAR]-(f2)-[]-(p2:Pangenome) WHERE f1.annotation IS NOT NULL AND f2.annotation IS NOT NULL AND sim.identity>=0.8 AND p1<>p2 RETURN f1.name,f2.name;match (p:Pangenome)-[]-(f:Family)-[:NEIGHBOR]-(n:Family) WHERE n.annotation IS NOT NULL RETURN p.name,COLLECT(DISTINCT n.name);match (p:Pangenome)-[]-(f:Family) WHERE f.annotation IS NOT NULL RETURN p.name,COUNT(DISTINCT f);MATCH (f1:Family)-[]-(m:Module)-[]-(f2:Family) MATCH (f1)-[sim:IS_SIMILAR]-(f2) RETURN m, AVG(sim.identity) as avg_identity order by avg_identity desc;match (p1:Pangenome)-[]-(f1:Family)-[sim:IS_SIMILAR]-(f2)-[]-(p2:Pangenome) WHERE f1.annotation IS NOT NULL AND f2.annotation IS NOT NULL AND sim.identity>=0.8 AND p1<>p2 RETURN f1.name,f2.name limit 2;match (f1:Family)-[]-(m:Module) return f1.name,COUNT(distinct  m) as modules order by modules desc limit 10;MATCH (f1:Family)-[sim:IS_SIMILAR]-(f2:Family) WHERE sim.identity >= 0.8 AND sim.coverage >= 0.8 WITH f1, f2, sim ORDER BY sim.identity DESC,sim.coverage DESC LIMIT 10 MATCH (f1)-[]-(p1:Partition) MATCH (f2)-[]-(p2:Partition) RETURN f1.name, f2.name, p1.subpartition AS Partition1, p2.subpartition AS Partition2
;;;;;;;;Correct;Correct;Correct;Correct;3;https://drive.google.com/open?id=1WWkSdpp5FHXSnhfrjdL7BylcFpDbBz0l;Complication | Added Collect in return shape;Complication | Added Collect in return shape;Semantic Where | Missing Condition, Wrong Property;Correct;Semantic Where , Semantic Return | Missing Condition, Missing Information;Correct;Semantic Pattern | Wrong Edge Direction;No Answer;No Answer;No Answer
;;;;;;;;;;;;;;Why collect? To return a list of genes.;Yes, they can be different.;Why you didn’t put put <> between the two families? Forgot to add this. Indeed we are not sure f1 and f2 are different. Question about the “join” : 2 nodes with same labels are different? Yes, they can be different.;;Why you didn’t put also f1annotation is not null? And why you didn’t return both families? Comprehension error of the question? Comprehension error. I did not see that both families had to have annotations.;;;;;
student-54;Accept.;java, ocaml, pyhton;4;4;Redis, Other;3;OpenCypher, SQL/PGQ, SPARQL;"match (n) return distinct labels(n);  // 9 labels";"match ()-[r]-() return distinct type(r); // 10 types";"match (n) return  distinct labels(n) as labs, keys(n) order by labs; // 18 results, some nodes has some optional properties";"match ()-[r]-() return distinct type(r) as t, keys(r); // 10 types with their properties";"match (n)-[r]->(m) return distinct labels(n), type(r), labels(m) ; // get the direction of the relationships between the nodes
match (n) with distinct labels(n) as labs, count(distinct keys(n)) as cnt where cnt > 1 return collect(labs) as lab; // find the nodes with some optionals properties
match (n) with distinct labels(n) as lab, keys(n) as ks return distinct lab, apoc.coll.sortText(ks);; // reduce the nodes in the previous list which has the same properties, but the cypher returns them in a random order. apoc lib is necessary

match (n) where labels(n) = ['Gene'] return properties(n) limit 1; // for each obtained label, get the type of each key
match (n) where labels(n) = ['Family'] and n.annotation is null return properties(n) limit 1; // exceptionnally for family, we found that it existed an optional key
match (n) where labels(n) = ['Family'] and n.annotation is not null return properties(n) limit 1;match ()-[r]-() where type(r) = 'IS_IN_CONTIG' return properties(r) limit 1; // and for t relationships";https://drive.google.com/open?id=1uOmCwnAbCDmYxmp05wmS2sOzwsu6JFDx;"match (p:Pangenome)--(f:Family)--(g:Gene) return distinct p.name, g.name; // 5477 answers with two types of pangenome";"match (p:Pangenome)--(f:Family)--(g:Gene)--(r:RGP)--(s:Spot) return distinct p.name, s.name; // 656 records";"match (p:Pangenome)--(f:Family)--(m:Module), (f:Family)-[r:IS_SIMILAR]-(f2:Family) where any(iden in r.identity where iden >= 0.8) return p, m; // 48 records";"match (f1:Family)-[r:IS_SIMILAR]-(f2:Family) where f1.annotation is not null and f2.annotation is not null and r.identity >= 0.8 return f1, f2; // 16 nodes with 9 pairs";"match (f1:Family)-[r:NEIGHBOR]->(f2:Family) where f2.annotation is not null return f1, f2; // 473 records";"match (p:Pangenome)--(f:Family) where f.annotation is not null return p.name, count(f); // Enterobacter.cloacae 110, Acinetobacter.baumannii 92";"match (m:Module)--(f:Family)-[r:IS_SIMILAR]-(f2:Family) where r.identity is not null return m, avg(r.identity) as sim_avg order by sim_avg desc; // 715 records";"match (m:Module)--(f:Family)-[r:IS_SIMILAR]-(f2:Family)--(m) where r.identity is not null return m.name, min(r.identity) as imin, max(r.identity) as imax; // 6 records";"match (f:Family)--(m:Module) return f.name, count(m) as num order by num desc limit 10; // 10 records";"match (m:Module)--(f1:Family)-[r:IS_SIMILAR]-(f2:Family)--(m) where r.identity >= 0.8 with f1, f2 match (p1:Partition)--(f1:Family)--(f2:Family)--(p2:Partition) return f1, p1, f2, p2; // 0 records"
;;;;;;;;Correct;Correct;Correct;Correct;1;https://drive.google.com/open?id=1uOmCwnAbCDmYxmp05wmS2sOzwsu6JFDx;Correct;Correct;Semantic Where, Semantic Return | Missing Condition, Missing Distinct;Semantic Pattern | Missing Node;Semantic Where , Semantic Return | Missing Condition, Missing Information;Correct;Semantic Pattern | Wrong Edge Direction;Semantic Return | Missing Limit, Missing Information;Correct;Semantic Pattern, Semantic Where | Missing Condition, 
;;;;;;;;;;;;;;;;Why you didn’t put put <> between the two families? Because the two families cannot be the same because of the semantics: a family node cannot be similar to itself (this does not make sense to be). I have also written a query to check this and have obtained 0 responses for family nodes similar to themselves. Question about the “join” : 2 nodes with same labels are different? In Neo4j yes, they are different bacuse the system will generate a unique identifier for each (even if they have the same label and even the same properties).;;Why you didn’t put also f1annotation is not null? And why you didn’t return both families? Comprehension error of the question? I forgot to write this check.;;;;;
